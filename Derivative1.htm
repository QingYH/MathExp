<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>导数直观理解：几何意义与物理意义</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3a0ca3;
            --accent: #f72585;
            --light: #f8f9fa;
            --dark: #212529;
            --success: #4cc9f0;
            --warning: #f8961e;
            --danger: #e63946;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--dark);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.8rem;
            color: var(--primary);
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        h2 {
            font-size: 2rem;
            color: var(--secondary);
            margin: 25px 0 15px;
            border-bottom: 3px solid var(--accent);
            padding-bottom: 8px;
        }
        
        h3 {
            font-size: 1.6rem;
            color: var(--primary);
            margin: 20px 0 10px;
        }
        
        p {
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .canvas-container {
            width: 100%;
            height: 400px;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            background: #f8f9fa;
            border: 2px solid var(--primary);
            position: relative;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .car-track-container {
            width: 100%;
            height: 120px;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            background: #f8f9fa;
            border: 2px solid var(--primary);
            position: relative;
        }
        
        .car-track {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 4px;
            background: #333;
            transform: translateY(-50%);
        }
        
        .car {
            position: absolute;
            width: 60px;
            height: 30px;
            background: var(--accent);
            border-radius: 10px 10px 0 0;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: left 0.1s linear;
            transform-origin: center;
        }
        
        .car::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: #333;
            border-radius: 50%;
            bottom: -10px;
            left: 5px;
        }
        
        .car::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: #333;
            border-radius: 50%;
            bottom: -10px;
            right: 5px;
        }
        
        .car-top {
            position: absolute;
            width: 40px;
            height: 20px;
            background: var(--danger);
            top: -20px;
            left: 10px;
            border-radius: 5px 5px 0 0;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(67, 97, 238, 0.1);
            border-radius: 10px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--secondary);
        }
        
        select, button, input[type="range"] {
            padding: 10px 15px;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            background: var(--primary);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, button:hover {
            background: var(--secondary);
            transform: scale(1.05);
        }
        
        button {
            background: var(--accent);
        }
        
        button:hover {
            background: #d9046d;
        }
        
        input[type="range"] {
            background: transparent;
            padding: 0;
        }
        
        .explanation {
            background: rgba(76, 201, 240, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid var(--success);
        }
        
        .key-point {
            background: rgba(248, 150, 30, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 5px solid var(--warning);
        }
        
        .math {
            font-family: 'Cambria Math', serif;
            font-style: italic;
            background: rgba(0, 0, 0, 0.05);
            padding: 5px 10px;
            border-radius: 5px;
            display: inline-block;
        }
        
        .highlight {
            color: var(--accent);
            font-weight: 700;
        }
        
        .function-display {
            text-align: center;
            font-size: 1.5rem;
            margin: 15px 0;
            padding: 10px;
            background: rgba(67, 97, 238, 0.1);
            border-radius: 10px;
        }
        
        .data-panel {
            background: rgba(67, 97, 238, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .data-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        
        .data-label {
            font-weight: bold;
            color: var(--secondary);
        }
        
        .data-value {
            color: var(--primary);
        }
        
        .speed-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            font-weight: bold;
            border-left: 5px solid var(--success);
        }
        
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .color-label {
            font-size: 0.9rem;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: var(--dark);
            font-size: 1rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            
            h2 {
                font-size: 1.7rem;
            }
            
            .canvas-container {
                height: 350px;
            }
            
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>导数直观理解：几何意义与物理意义</h1>
            <p>通过图形和动画直观展示导数的定义、几何意义、物理意义以及不可导情况</p>
        </header>
        
        <section class="card">
            <h2>导数的定义</h2>
            <p>导数描述的是函数在某一点处的瞬时变化率，数学上定义为：</p>
            <div class="function-display">
                f'(x) = lim<sub>h→0</sub> [f(x+h) - f(x)] / h
            </div>
            <p>这个极限值如果存在，我们就说函数在点x处可导。</p>
            
            <div class="canvas-container">
                <canvas id="derivativeDefinition"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="functionSelect">选择函数:</label>
                    <select id="functionSelect">
                        <option value="quadratic">二次函数: f(x) = x²</option>
                        <option value="sin">正弦函数: f(x) = sin(x)</option>
                        <option value="cubic">三次函数: f(x) = x³</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="pointSelect">选择点:</label>
                    <input type="range" id="pointSelect" min="-3" max="3" step="0.1" value="1">
                    <span id="pointValue">x = 1.0</span>
                </div>
                <div class="control-group">
                    <label for="hValue">h值:</label>
                    <input type="range" id="hValue" min="0.01" max="2" step="0.01" value="1">
                    <span id="hValueDisplay">h = 1.00</span>
                </div>
                <button id="animateBtn">动画演示</button>
            </div>
            
            <div class="explanation">
                <h3>几何解释</h3>
                <p>导数的几何意义是函数图像在某一点处的切线斜率。当h趋近于0时，割线逐渐接近切线。</p>
                <p>在上面的演示中，红色线表示割线，<span style="color: #f72585;">粉红色线</span>表示切线。当h值减小时，割线逐渐接近切线。</p>
            </div>
        </section>
        
        <section class="card">
            <h2>不可导的情况</h2>
            <p>并非所有函数在所有点都可导。函数在以下情况下可能不可导：</p>
            <ul>
                <li>函数在该点不连续</li>
                <li>函数在该点有尖点（左右导数不相等）</li>
                <li>函数在该点有垂直切线（导数为无穷大）</li>
            </ul>
            
            <div class="canvas-container">
                <canvas id="nonDifferentiable"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="nonDiffSelect">选择不可导类型:</label>
                    <select id="nonDiffSelect">
                        <option value="corner">尖点: f(x) = |x|</option>
                        <option value="vertical">垂直切线: f(x) = x^(1/3)</option>
                        <option value="discontinuous">不连续: f(x) = 1/x (x≠0)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="nonDiffPoint">选择点:</label>
                    <input type="range" id="nonDiffPoint" min="-2" max="2" step="0.01" value="0">
                    <span id="nonDiffPointValue">x = 0.0</span>
                </div>
                <button id="nonDiffAnimateBtn">在不可导点附近动态演示</button>
            </div>
            
            <div class="key-point">
                <h3>关键点</h3>
                <p>在尖点处（如绝对值函数在x=0处），左右导数存在但不相等，因此函数在该点不可导。</p>
                <p>在垂直切线处（如立方根函数在x=0处），导数趋于无穷大，因此函数在该点不可导。</p>
                <p>在不连续点处，函数显然不可导。</p>
            </div>
        </section>
        
        <section class="card">
            <h2>可导与连续的关系</h2>
            <p>可导性与连续性之间有重要关系：</p>
            <div class="function-display">
                可导 ⇒ 连续
            </div>
            <p>但反过来不一定成立：连续 ⇏ 可导</p>
            
            <div class="canvas-container">
                <canvas id="differentiableContinuous"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="relationSelect">选择函数:</label>
                    <select id="relationSelect">
                        <option value="differentiable">可导且连续: f(x) = x²</option>
                        <option value="continuousNotDiff">连续但不可导: f(x) = |x|</option>
                        <option value="notContinuous">不连续: f(x) = 1/x (x≠0)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="relationPoint">选择点:</label>
                    <input type="range" id="relationPoint" min="-2" max="2" step="0.1" value="0">
                    <span id="relationPointValue">x = 0.0</span>
                </div>
            </div>
            
            <div class="explanation">
                <h3>关系解释</h3>
                <p>如果一个函数在某点可导，那么它一定在该点连续。这是因为可导要求函数在该点的极限存在且等于函数值。</p>
                <p>但是，连续的函数不一定可导。绝对值函数在x=0处是连续的，但不可导，因为左右导数不相等。</p>
            </div>
        </section>
        
        <section class="card">
            <h2>导数的物理意义</h2>
            <p>在物理学中，导数有广泛的应用：</p>
            <ul>
                <li>位移函数的导数是速度</li>
                <li>速度函数的导数是加速度</li>
                <li>在经济学中，成本函数的导数是边际成本</li>
                <li>在生物学中，种群数量函数的导数是种群增长率</li>
            </ul>
            
            <div class="canvas-container">
                <canvas id="physicsMeaning"></canvas>
                <div class="speed-indicator" id="speedIndicator">
                    速度: 0.00 m/s
                </div>
            </div>
            
            <!-- 小汽车运动轨道 -->
            <div class="car-track-container">
                <div class="car-track"></div>
                <div class="car" id="car">
                    <div class="car-top"></div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label for="physicsSelect">选择物理量:</label>
                    <select id="physicsSelect">
                        <option value="position">位移函数</option>
                        <option value="velocity">速度函数</option>
                        <option value="acceleration">加速度函数</option>
                    </select>
                </div>
                <div class="control-group">
                    <button id="startMotion">开始运动</button>
                    <button id="pauseMotion">暂停</button>
                    <button id="resetMotion">重置</button>
                </div>
                <div class="control-group">
                    <label for="timeScale">时间缩放:</label>
                    <input type="range" id="timeScale" min="0.1" max="3" step="0.1" value="1">
                    <span id="timeScaleValue">1.0x</span>
                </div>
            </div>
            
            <div class="data-panel">
                <div class="data-item">
                    <span class="data-label">时间:</span>
                    <span class="data-value" id="timeValue">0.00 s</span>
                </div>
                <div class="data-item">
                    <span class="data-label">位移:</span>
                    <span class="data-value" id="positionValue">0.00 m</span>
                </div>
                <div class="data-item">
                    <span class="data-label">速度:</span>
                    <span class="data-value" id="velocityValue">0.00 m/s</span>
                </div>
                <div class="data-item">
                    <span class="data-label">加速度:</span>
                    <span class="data-value" id="accelerationValue">0.00 m/s²</span>
                </div>
            </div>
            
            <!-- 小汽车颜色含义说明 -->
            <div class="color-legend">
                <div class="color-item">
                    <div class="color-box" style="background-color: #4cc9f0;"></div>
                    <span class="color-label">快速正向 (>1.5 m/s)</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #4361ee;"></div>
                    <span class="color-label">中速正向 (0.5-1.5 m/s)</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #f72585;"></div>
                    <span class="color-label">慢速正向 (0-0.5 m/s)</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #f8961e;"></div>
                    <span class="color-label">慢速反向 (-0.5-0 m/s)</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #e63946;"></div>
                    <span class="color-label">中速反向 (-1.5--0.5 m/s)</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #d90429;"></div>
                    <span class="color-label">快速反向 (<-1.5 m/s)</span>
                </div>
            </div>
            
            <div class="key-point">
                <h3>物理意义解释</h3>
                <p>在位移-时间图中，某一点的切线斜率表示该时刻的瞬时速度。</p>
                <p>在速度-时间图中，某一点的切线斜率表示该时刻的瞬时加速度。</p>
                <p>导数帮助我们理解变化率，这是理解物理世界动态变化的关键。</p>
                <p>观察小汽车的运动，可以看到位移、速度和加速度之间的关系。</p>
                <p><strong>小汽车颜色说明：</strong> 小汽车的颜色根据速度大小和方向变化，蓝色表示正向运动，红色表示反向运动，颜色越深表示速度越快。</p>
                <p><strong>运动方向说明：</strong> 小汽车的运动方向与速度方向一致，速度为正时向前运动，速度为负时向后运动。</p>
                <p><strong>自适应镜头：</strong> 图形窗口会像摄像镜头一样跟随小汽车移动，确保小汽车始终在视野中央。</p>
            </div>
        </section>
        
        <footer>
            <p>导数直观理解演示 &copy; 2025 | 设计用于帮助学生直观理解导数概念</p>
        </footer>
    </div>

    <script>
        // 获取所有canvas元素和上下文
        const derivativeCanvas = document.getElementById('derivativeDefinition');
        const nonDiffCanvas = document.getElementById('nonDifferentiable');
        const relationCanvas = document.getElementById('differentiableContinuous');
        const physicsCanvas = document.getElementById('physicsMeaning');
        
        const derivativeCtx = derivativeCanvas.getContext('2d');
        const nonDiffCtx = nonDiffCanvas.getContext('2d');
        const relationCtx = relationCanvas.getContext('2d');
        const physicsCtx = physicsCanvas.getContext('2d');
        
        // 获取小汽车元素和速度指示器
        const car = document.getElementById('car');
        const speedIndicator = document.getElementById('speedIndicator');
        
        // 设置canvas尺寸
        function setCanvasSize(canvas) {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        // 初始化所有canvas尺寸
        setCanvasSize(derivativeCanvas);
        setCanvasSize(nonDiffCanvas);
        setCanvasSize(relationCanvas);
        setCanvasSize(physicsCanvas);
        
        // 窗口调整大小时重置canvas尺寸
        window.addEventListener('resize', function() {
            setCanvasSize(derivativeCanvas);
            setCanvasSize(nonDiffCanvas);
            setCanvasSize(relationCanvas);
            setCanvasSize(physicsCanvas);
            drawAll();
        });
        
        // 坐标转换函数
        function toCanvasX(x, canvas, xMin, xMax) {
            return (x - xMin) / (xMax - xMin) * canvas.width;
        }
        
        function toCanvasY(y, canvas, yMin, yMax) {
            return canvas.height - (y - yMin) / (yMax - yMin) * canvas.height;
        }
        
        // 绘制坐标轴
        function drawAxes(ctx, canvas, xMin, xMax, yMin, yMax) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            
            // 垂直网格线
            for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x++) {
                if (x === 0) continue;
                const canvasX = toCanvasX(x, canvas, xMin, xMax);
                ctx.beginPath();
                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, canvas.height);
                ctx.stroke();
            }
            
            // 水平网格线
            for (let y = Math.ceil(yMin); y <= Math.floor(yMax); y++) {
                if (y === 0) continue;
                const canvasY = toCanvasY(y, canvas, yMin, yMax);
                ctx.beginPath();
                ctx.moveTo(0, canvasY);
                ctx.lineTo(canvas.width, canvasY);
                ctx.stroke();
            }
            
            // 绘制坐标轴
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // x轴
            const xAxisY = toCanvasY(0, canvas, yMin, yMax);
            ctx.beginPath();
            ctx.moveTo(0, xAxisY);
            ctx.lineTo(canvas.width, xAxisY);
            ctx.stroke();
            
            // y轴
            const yAxisX = toCanvasX(0, canvas, xMin, xMax);
            ctx.beginPath();
            ctx.moveTo(yAxisX, 0);
            ctx.lineTo(yAxisX, canvas.height);
            ctx.stroke();
            
            // 绘制刻度
            ctx.fillStyle = '#000';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // x轴刻度
            for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x++) {
                if (x === 0) continue;
                const canvasX = toCanvasX(x, canvas, xMin, xMax);
                ctx.beginPath();
                ctx.moveTo(canvasX, xAxisY - 5);
                ctx.lineTo(canvasX, xAxisY + 5);
                ctx.stroke();
                ctx.fillText(x.toString(), canvasX, xAxisY + 10);
            }
            
            // y轴刻度
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let y = Math.ceil(yMin); y <= Math.floor(yMax); y++) {
                if (y === 0) continue;
                const canvasY = toCanvasY(y, canvas, yMin, yMax);
                ctx.beginPath();
                ctx.moveTo(yAxisX - 5, canvasY);
                ctx.lineTo(yAxisX + 5, canvasY);
                ctx.stroke();
                ctx.fillText(y.toString(), yAxisX - 10, canvasY);
            }
            
            // 原点标记
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText('O', yAxisX - 5, xAxisY + 5);
        }
        
        // 函数定义
        const functions = {
            quadratic: x => x * x,
            sin: x => Math.sin(x),
            cubic: x => x * x * x,
            absolute: x => Math.abs(x),
            cubeRoot: x => Math.cbrt(x),
            reciprocal: x => x !== 0 ? 1 / x : NaN
        };
        
        // 导数定义（数值近似）
        function derivative(f, x, h = 0.001) {
            return (f(x + h) - f(x)) / h;
        }
        
        // 自适应坐标范围 - 用于导数定义部分
        function getDerivativeRange(funcName, x) {
            let xMin, xMax, yMin, yMax;
            
            switch(funcName) {
                case 'quadratic':
                    xMin = -3; xMax = 3;
                    yMin = -2; yMax = 10;
                    break;
                case 'sin':
                    xMin = -3; xMax = 3;
                    yMin = -2; yMax = 2;
                    break;
                case 'cubic':
                    xMin = -3; xMax = 3;
                    yMin = -10; yMax = 10;
                    break;
                default:
                    xMin = -3; xMax = 3;
                    yMin = -2; yMax = 10;
            }
            
            // 确保当前点x在视野范围内
            if (x < xMin) xMin = x - 1;
            if (x > xMax) xMax = x + 1;
            
            return { xMin, xMax, yMin, yMax };
        }
        
        // 绘制函数
        function drawFunction(ctx, canvas, f, xMin, xMax, yMin, yMax, color = '#4361ee', lineWidth = 3) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            
            let firstPoint = true;
            for (let i = 0; i <= canvas.width; i++) {
                const x = xMin + (i / canvas.width) * (xMax - xMin);
                const y = f(x);
                
                if (isNaN(y) || !isFinite(y)) {
                    firstPoint = true;
                    continue;
                }
                
                const canvasX = i;
                const canvasY = toCanvasY(y, canvas, yMin, yMax);
                
                if (firstPoint) {
                    ctx.moveTo(canvasX, canvasY);
                    firstPoint = false;
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            
            ctx.stroke();
        }
        
        // 绘制割线和切线 - 修改切线颜色为粉红色
        function drawTangent(ctx, canvas, f, x, h, xMin, xMax, yMin, yMax) {
            const canvasX = toCanvasX(x, canvas, xMin, xMax);
            const canvasY = toCanvasY(f(x), canvas, yMin, yMax);
            
            // 绘制点
            ctx.fillStyle = '#f72585';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制割线
            const slope = (f(x + h) - f(x)) / h;
            const y1 = f(x) - slope * (x - xMin);
            const y2 = f(x) + slope * (xMax - x);
            
            const canvasY1 = toCanvasY(y1, canvas, yMin, yMax);
            const canvasY2 = toCanvasY(y2, canvas, yMin, yMax);
            
            ctx.strokeStyle = '#e63946';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, canvasY1);
            ctx.lineTo(canvas.width, canvasY2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 绘制切线（当h很小时）- 修改为粉红色
            if (h < 0.1) {
                const exactSlope = derivative(f, x);
                if (isFinite(exactSlope)) {
                    const tangentY1 = f(x) - exactSlope * (x - xMin);
                    const tangentY2 = f(x) + exactSlope * (xMax - x);
                    
                    const canvasTangentY1 = toCanvasY(tangentY1, canvas, yMin, yMax);
                    const canvasTangentY2 = toCanvasY(tangentY2, canvas, yMin, yMax);
                    
                    // 直接使用粉红色值
                    ctx.strokeStyle = '#f72585';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, canvasTangentY1);
                    ctx.lineTo(canvas.width, canvasTangentY2);
                    ctx.stroke();
                }
            }
            
            // 显示斜率值
            ctx.fillStyle = '#000';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`斜率: ${slope.toFixed(2)}`, 10, 10);
        }
        
        // 绘制导数定义图形
        function drawDerivativeDefinition() {
            const functionSelect = document.getElementById('functionSelect');
            const pointSelect = document.getElementById('pointSelect');
            const hValue = document.getElementById('hValue');
            
            const funcName = functionSelect.value;
            const x = parseFloat(pointSelect.value);
            const h = parseFloat(hValue.value);
            
            const f = functions[funcName];
            
            // 使用自适应坐标范围
            const { xMin, xMax, yMin, yMax } = getDerivativeRange(funcName, x);
            
            drawAxes(derivativeCtx, derivativeCanvas, xMin, xMax, yMin, yMax);
            drawFunction(derivativeCtx, derivativeCanvas, f, xMin, xMax, yMin, yMax);
            drawTangent(derivativeCtx, derivativeCanvas, f, x, h, xMin, xMax, yMin, yMax);
        }
        
        // 绘制不可导情况
        let nonDiffAnimation = null;
        let nonDiffDirection = 1; // 1表示向右，-1表示向左
        
        function drawNonDifferentiable() {
            const xMin = -2, xMax = 2, yMin = -2, yMax = 2;
            drawAxes(nonDiffCtx, nonDiffCanvas, xMin, xMax, yMin, yMax);
            
            const nonDiffSelect = document.getElementById('nonDiffSelect');
            const nonDiffPoint = document.getElementById('nonDiffPoint');
            
            const funcType = nonDiffSelect.value;
            const x = parseFloat(nonDiffPoint.value);
            
            let f;
            switch (funcType) {
                case 'corner':
                    f = functions.absolute;
                    break;
                case 'vertical':
                    f = functions.cubeRoot;
                    break;
                case 'discontinuous':
                    f = functions.reciprocal;
                    break;
            }
            
            drawFunction(nonDiffCtx, nonDiffCanvas, f, xMin, xMax, yMin, yMax);
            
            // 绘制点
            const canvasX = toCanvasX(x, nonDiffCanvas, xMin, xMax);
            const y = f(x);
            
            if (!isNaN(y) && isFinite(y)) {
                const canvasY = toCanvasY(y, nonDiffCanvas, yMin, yMax);
                
                nonDiffCtx.fillStyle = '#f72585';
                nonDiffCtx.beginPath();
                nonDiffCtx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
                nonDiffCtx.fill();
                
                // 尝试绘制切线 - 修改为粉红色
                try {
                    const slope = derivative(f, x);
                    if (isFinite(slope)) {
                        const tangentY1 = f(x) - slope * (x - xMin);
                        const tangentY2 = f(x) + slope * (xMax - x);
                        
                        const canvasTangentY1 = toCanvasY(tangentY1, nonDiffCanvas, yMin, yMax);
                        const canvasTangentY2 = toCanvasY(tangentY2, nonDiffCanvas, yMin, yMax);
                        
                        // 直接使用粉红色值
                        nonDiffCtx.strokeStyle = '#f72585';
                        nonDiffCtx.lineWidth = 2;
                        nonDiffCtx.beginPath();
                        nonDiffCtx.moveTo(0, canvasTangentY1);
                        nonDiffCtx.lineTo(nonDiffCanvas.width, canvasTangentY2);
                        nonDiffCtx.stroke();
                        
                        nonDiffCtx.fillStyle = '#000';
                        nonDiffCtx.font = '16px Arial';
                        nonDiffCtx.textAlign = 'left';
                        nonDiffCtx.textBaseline = 'top';
                        nonDiffCtx.fillText(`斜率: ${slope.toFixed(2)}`, 10, 10);
                    } else {
                        nonDiffCtx.fillStyle = '#e63946';
                        nonDiffCtx.font = '16px Arial';
                        nonDiffCtx.textAlign = 'left';
                        nonDiffCtx.textBaseline = 'top';
                        nonDiffCtx.fillText(`该点不可导`, 10, 10);
                    }
                } catch (e) {
                    nonDiffCtx.fillStyle = '#e63946';
                    nonDiffCtx.font = '16px Arial';
                    nonDiffCtx.textAlign = 'left';
                    nonDiffCtx.textBaseline = 'top';
                    nonDiffCtx.fillText(`该点不可导`, 10, 10);
                }
            }
        }
        
        // 在不可导点附近动态演示 - 修改为持续往返
        function animateNonDifferentiable() {
            if (nonDiffAnimation) {
                cancelAnimationFrame(nonDiffAnimation);
                nonDiffAnimation = null;
                document.getElementById('nonDiffAnimateBtn').textContent = "在不可导点附近动态演示";
                return;
            }
            
            document.getElementById('nonDiffAnimateBtn').textContent = "停止演示";
            
            const nonDiffPoint = document.getElementById('nonDiffPoint');
            const nonDiffSelect = document.getElementById('nonDiffSelect');
            const funcType = nonDiffSelect.value;
            
            let x = parseFloat(nonDiffPoint.value);
            let speed = 0.01;
            
            // 根据函数类型设置动画范围
            let minX, maxX;
            if (funcType === 'discontinuous') {
                minX = -1.5;
                maxX = -0.1;
                x = minX;
                nonDiffDirection = 1;
            } else {
                minX = -1;
                maxX = 1;
            }
            
            function animate() {
                x += nonDiffDirection * speed;
                
                // 检查边界并改变方向
                if (x >= maxX) {
                    x = maxX;
                    nonDiffDirection = -1;
                } else if (x <= minX) {
                    x = minX;
                    nonDiffDirection = 1;
                }
                
                // 对于不连续函数，跳过0点
                if (funcType === 'discontinuous' && Math.abs(x) < 0.1) {
                    x = (nonDiffDirection > 0) ? 0.1 : -0.1;
                }
                
                // 更新滑块和显示
                nonDiffPoint.value = x;
                document.getElementById('nonDiffPointValue').textContent = `x = ${x.toFixed(2)}`;
                
                // 重绘图形
                drawNonDifferentiable();
                
                // 继续动画
                nonDiffAnimation = requestAnimationFrame(animate);
            }
            
            nonDiffAnimation = requestAnimationFrame(animate);
        }
        
        // 绘制可导与连续关系
        function drawDifferentiableContinuous() {
            const xMin = -2, xMax = 2, yMin = -2, yMax = 2;
            drawAxes(relationCtx, relationCanvas, xMin, xMax, yMin, yMax);
            
            const relationSelect = document.getElementById('relationSelect');
            const relationPoint = document.getElementById('relationPoint');
            
            const funcType = relationSelect.value;
            const x = parseFloat(relationPoint.value);
            
            let f;
            switch (funcType) {
                case 'differentiable':
                    f = functions.quadratic;
                    break;
                case 'continuousNotDiff':
                    f = functions.absolute;
                    break;
                case 'notContinuous':
                    f = functions.reciprocal;
                    break;
            }
            
            drawFunction(relationCtx, relationCanvas, f, xMin, xMax, yMin, yMax);
            
            // 绘制点
            const canvasX = toCanvasX(x, relationCanvas, xMin, xMax);
            const y = f(x);
            
            if (!isNaN(y) && isFinite(y)) {
                const canvasY = toCanvasY(y, relationCanvas, yMin, yMax);
                
                relationCtx.fillStyle = '#f72585';
                relationCtx.beginPath();
                relationCtx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
                relationCtx.fill();
                
                // 尝试绘制切线 - 修改为粉红色
                try {
                    const slope = derivative(f, x);
                    if (isFinite(slope)) {
                        const tangentY1 = f(x) - slope * (x - xMin);
                        const tangentY2 = f(x) + slope * (xMax - x);
                        
                        const canvasTangentY1 = toCanvasY(tangentY1, relationCanvas, yMin, yMax);
                        const canvasTangentY2 = toCanvasY(tangentY2, relationCanvas, yMin, yMax);
                        
                        // 直接使用粉红色值
                        relationCtx.strokeStyle = '#f72585';
                        relationCtx.lineWidth = 2;
                        relationCtx.beginPath();
                        relationCtx.moveTo(0, canvasTangentY1);
                        relationCtx.lineTo(relationCanvas.width, canvasTangentY2);
                        relationCtx.stroke();
                        
                        relationCtx.fillStyle = '#4cc9f0';
                        relationCtx.font = '16px Arial';
                        relationCtx.textAlign = 'left';
                        relationCtx.textBaseline = 'top';
                        relationCtx.fillText(`该点可导且连续`, 10, 10);
                    } else {
                        relationCtx.fillStyle = '#f8961e';
                        relationCtx.font = '16px Arial';
                        relationCtx.textAlign = 'left';
                        relationCtx.textBaseline = 'top';
                        relationCtx.fillText(`该点连续但不可导`, 10, 10);
                    }
                } catch (e) {
                    relationCtx.fillStyle = '#e63946';
                    relationCtx.font = '16px Arial';
                    relationCtx.textAlign = 'left';
                    relationCtx.textBaseline = 'top';
                    relationCtx.fillText(`该点不连续`, 10, 10);
                }
            } else {
                relationCtx.fillStyle = '#e63946';
                relationCtx.font = '16px Arial';
                relationCtx.textAlign = 'left';
                relationCtx.textBaseline = 'top';
                relationCtx.fillText(`该点不连续`, 10, 10);
            }
        }
        
        // 物理意义部分
        let motionAnimation = null;
        let isMotionPaused = false;
        let motionTime = 0;
        
        // 位移函数
        function positionFunction(t) {
            return 2 * Math.sin(t) + 0.5 * Math.sin(3 * t);
        }
        
        // 速度函数（位移的导数）
        function velocityFunction(t) {
            return 2 * Math.cos(t) + 1.5 * Math.cos(3 * t);
        }
        
        // 加速度函数（速度的导数）
        function accelerationFunction(t) {
            return -2 * Math.sin(t) - 4.5 * Math.sin(3 * t);
        }
        
        // 自适应坐标范围 - 用于物理意义部分
        function getPhysicsRange(funcType, currentTime, currentPosition) {
            let xMin, xMax, yMin, yMax;
            
            // 根据当前时间和小汽车位置调整视野范围
            const timeWindow = 8; // 时间窗口大小
            const positionWindow = 4; // 位置窗口大小
            
            xMin = currentTime - timeWindow / 2;
            xMax = currentTime + timeWindow / 2;
            
            // 根据函数类型调整y轴范围
            switch(funcType) {
                case 'position':
                    yMin = currentPosition - positionWindow / 2;
                    yMax = currentPosition + positionWindow / 2;
                    break;
                case 'velocity':
                    yMin = -3;
                    yMax = 3;
                    break;
                case 'acceleration':
                    yMin = -5;
                    yMax = 5;
                    break;
                default:
                    yMin = -3;
                    yMax = 3;
            }
            
            return { xMin, xMax, yMin, yMax };
        }
        
        // 绘制物理意义图形
        function drawPhysicsMeaning() {
            const physicsSelect = document.getElementById('physicsSelect');
            const funcType = physicsSelect.value;
            
            // 使用自适应坐标范围，确保小汽车始终在视野中央
            const { xMin, xMax, yMin, yMax } = getPhysicsRange(funcType, motionTime, positionFunction(motionTime));
            
            drawAxes(physicsCtx, physicsCanvas, xMin, xMax, yMin, yMax);
            
            // 根据选择的函数类型绘制不同的函数
            let f;
            switch (funcType) {
                case 'position':
                    f = positionFunction;
                    break;
                case 'velocity':
                    f = velocityFunction;
                    break;
                case 'acceleration':
                    f = accelerationFunction;
                    break;
            }
            
            drawFunction(physicsCtx, physicsCanvas, f, xMin, xMax, yMin, yMax, '#4361ee', 3);
            
            // 绘制当前时间点
            const canvasX = toCanvasX(motionTime, physicsCanvas, xMin, xMax);
            const y = f(motionTime);
            
            if (!isNaN(y) && isFinite(y)) {
                const canvasY = toCanvasY(y, physicsCanvas, yMin, yMax);
                
                physicsCtx.fillStyle = '#f72585';
                physicsCtx.beginPath();
                physicsCtx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
                physicsCtx.fill();
                
                // 绘制切线 - 修改为粉红色
                const slope = derivative(f, motionTime);
                if (isFinite(slope)) {
                    const tangentY1 = y - slope * (motionTime - xMin);
                    const tangentY2 = y + slope * (xMax - motionTime);
                    
                    const canvasTangentY1 = toCanvasY(tangentY1, physicsCanvas, yMin, yMax);
                    const canvasTangentY2 = toCanvasY(tangentY2, physicsCanvas, yMin, yMax);
                    
                    // 直接使用粉红色值
                    physicsCtx.strokeStyle = '#f72585';
                    physicsCtx.lineWidth = 2;
                    physicsCtx.beginPath();
                    physicsCtx.moveTo(0, canvasTangentY1);
                    physicsCtx.lineTo(physicsCanvas.width, canvasTangentY2);
                    physicsCtx.stroke();
                    
                    // 显示导数意义
                    physicsCtx.fillStyle = '#000';
                    physicsCtx.font = '16px Arial';
                    physicsCtx.textAlign = 'left';
                    physicsCtx.textBaseline = 'top';
                    
                    let derivativeMeaning;
                    if (funcType === 'position') {
                        derivativeMeaning = "速度";
                    } else if (funcType === 'velocity') {
                        derivativeMeaning = "加速度";
                    } else {
                        derivativeMeaning = "加加速度";
                    }
                    
                    physicsCtx.fillText(`瞬时${derivativeMeaning}: ${slope.toFixed(2)}`, 10, 10);
                }
            }
            
            // 更新小汽车位置和方向
            updateCarPosition();
        }
        
        // 更新小汽车位置和方向 - 修复反向运动问题
        function updateCarPosition() {
            const velocity = velocityFunction(motionTime);
            const position = positionFunction(motionTime);
            
            // 更新小汽车位置 - 使用百分比定位
            const trackWidth = document.querySelector('.car-track-container').offsetWidth;
            const carWidth = 60; // 小汽车宽度
            
            // 将位置映射到轨道上的位置
            const minPosition = -3; // 最小位置值
            const maxPosition = 3;  // 最大位置值
            const positionRange = maxPosition - minPosition;
            
            // 计算小汽车在轨道上的位置百分比
            let positionPercent = (position - minPosition) / positionRange;
            positionPercent = Math.max(0, Math.min(1, positionPercent)); // 限制在0-1范围内
            
            // 计算小汽车在轨道上的实际位置（像素）
            const carPosition = positionPercent * (trackWidth - carWidth);
            
            // 更新小汽车位置
            car.style.left = `${carPosition}px`;
            
            // 更新小汽车方向 - 根据速度方向调整，但不翻转
            // 使用水平翻转而不是旋转，避免倒立
            if (velocity < 0) {
                // 反向运动 - 水平翻转
                car.style.transform = `translate(-50%, -50%) scaleX(-1)`;
            } else {
                // 正向运动 - 正常方向
                car.style.transform = `translate(-50%, -50%) scaleX(1)`;
            }
            
            // 根据速度大小更新小汽车颜色
            updateCarColor(velocity);
            
            // 更新速度指示器
            speedIndicator.textContent = `速度: ${velocity.toFixed(2)} m/s`;
            
            // 更新数据面板
            document.getElementById('timeValue').textContent = `${motionTime.toFixed(2)} s`;
            document.getElementById('positionValue').textContent = `${position.toFixed(2)} m`;
            document.getElementById('velocityValue').textContent = `${velocity.toFixed(2)} m/s`;
            document.getElementById('accelerationValue').textContent = `${accelerationFunction(motionTime).toFixed(2)} m/s²`;
        }
        
        // 根据速度更新小汽车颜色
        function updateCarColor(velocity) {
            let color;
            
            if (velocity > 1.5) {
                color = '#4cc9f0'; // 快速正向
            } else if (velocity > 0.5) {
                color = '#4361ee'; // 中速正向
            } else if (velocity > 0) {
                color = '#f72585'; // 慢速正向
            } else if (velocity > -0.5) {
                color = '#f8961e'; // 慢速反向
            } else if (velocity > -1.5) {
                color = '#e63946'; // 中速反向
            } else {
                color = '#d90429'; // 快速反向
            }
            
            car.style.backgroundColor = color;
        }
        
        // 开始运动
        function startMotion() {
            if (motionAnimation) return;
            
            const timeScale = parseFloat(document.getElementById('timeScale').value);
            let lastTime = performance.now();
            
            function animate(currentTime) {
                if (isMotionPaused) {
                    lastTime = currentTime;
                    motionAnimation = requestAnimationFrame(animate);
                    return;
                }
                
                const deltaTime = (currentTime - lastTime) / 1000; // 转换为秒
                lastTime = currentTime;
                
                motionTime += deltaTime * timeScale;
                
                drawPhysicsMeaning();
                motionAnimation = requestAnimationFrame(animate);
            }
            
            motionAnimation = requestAnimationFrame(animate);
        }
        
        // 暂停运动
        function pauseMotion() {
            isMotionPaused = !isMotionPaused;
            const pauseBtn = document.getElementById('pauseMotion');
            pauseBtn.textContent = isMotionPaused ? '继续' : '暂停';
        }
        
        // 重置运动
        function resetMotion() {
            motionTime = 0;
            drawPhysicsMeaning();
        }
        
        // 绘制所有图形
        function drawAll() {
            drawDerivativeDefinition();
            drawNonDifferentiable();
            drawDifferentiableContinuous();
            drawPhysicsMeaning();
        }
        
        // 初始化事件监听器
        function initEventListeners() {
            // 导数定义部分
            document.getElementById('functionSelect').addEventListener('change', drawDerivativeDefinition);
            document.getElementById('pointSelect').addEventListener('input', function() {
                document.getElementById('pointValue').textContent = `x = ${this.value}`;
                drawDerivativeDefinition();
            });
            document.getElementById('hValue').addEventListener('input', function() {
                document.getElementById('hValueDisplay').textContent = `h = ${parseFloat(this.value).toFixed(2)}`;
                drawDerivativeDefinition();
            });
            document.getElementById('animateBtn').addEventListener('click', function() {
                const hSlider = document.getElementById('hValue');
                let h = parseFloat(hSlider.value);
                
                function animateH() {
                    h -= 0.05;
                    if (h < 0.01) h = 0.01;
                    hSlider.value = h;
                    document.getElementById('hValueDisplay').textContent = `h = ${h.toFixed(2)}`;
                    drawDerivativeDefinition();
                    
                    if (h > 0.01) {
                        setTimeout(animateH, 100);
                    }
                }
                
                animateH();
            });
            
            // 不可导部分
            document.getElementById('nonDiffSelect').addEventListener('change', drawNonDifferentiable);
            document.getElementById('nonDiffPoint').addEventListener('input', function() {
                document.getElementById('nonDiffPointValue').textContent = `x = ${this.value}`;
                drawNonDifferentiable();
            });
            document.getElementById('nonDiffAnimateBtn').addEventListener('click', animateNonDifferentiable);
            
            // 可导与连续关系部分
            document.getElementById('relationSelect').addEventListener('change', drawDifferentiableContinuous);
            document.getElementById('relationPoint').addEventListener('input', function() {
                document.getElementById('relationPointValue').textContent = `x = ${this.value}`;
                drawDifferentiableContinuous();
            });
            
            // 物理意义部分
            document.getElementById('physicsSelect').addEventListener('change', drawPhysicsMeaning);
            document.getElementById('startMotion').addEventListener('click', startMotion);
            document.getElementById('pauseMotion').addEventListener('click', pauseMotion);
            document.getElementById('resetMotion').addEventListener('click', resetMotion);
            document.getElementById('timeScale').addEventListener('input', function() {
                document.getElementById('timeScaleValue').textContent = `${this.value}x`;
            });
        }
        
        // 初始化
        function init() {
            drawAll();
            initEventListeners();
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>




