<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‘†çº¿ç»•Yè½´æ—‹è½¬åŠ¨æ€æ¼”ç¤º</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c2e 0%, #1a1a3e 100%);
            color: #e0e0ff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            text-align: center;
            padding: 20px;
            background: rgba(10, 10, 40, 0.8);
            border-bottom: 1px solid rgba(64, 128, 255, 0.3);
            z-index: 10;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px rgba(79, 172, 254, 0.3);
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #a0a0ff;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.5;
        }
        
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
        }
        
        .controls-panel {
            width: 300px;
            background: rgba(15, 15, 50, 0.85);
            border-left: 1px solid rgba(64, 128, 255, 0.3);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        
        .control-group {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(64, 128, 255, 0.2);
        }
        
        .control-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #4facfe;
            display: flex;
            align-items: center;
        }
        
        .control-title i {
            margin-right: 10px;
            font-size: 1.3rem;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #b0b0ff;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(64, 128, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.8);
        }
        
        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #00f2fe;
            font-weight: bold;
        }
        
        button {
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            border: none;
            color: #0c0c2e;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 5px 5px 0;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.8);
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .info-box {
            background: rgba(20, 20, 60, 0.7);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #4facfe;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .info-box h3 {
            color: #4facfe;
            margin-bottom: 10px;
        }
        
        .param-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .param-item {
            background: rgba(30, 30, 70, 0.5);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .param-label {
            color: #a0a0ff;
            font-size: 0.85rem;
        }
        
        .param-value {
            color: #00f2fe;
            font-weight: bold;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border-radius: 2px;
        }
        
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            .controls-panel {
                width: 100%;
                height: 300px;
                border-left: none;
                border-top: 1px solid rgba(64, 128, 255, 0.3);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>æ‘†çº¿ç»•Yè½´æ—‹è½¬åŠ¨æ€æ¼”ç¤º</h1>
        <p class="subtitle">å±•ç¤ºæ‘†çº¿ï¼ˆæ—‹è½®çº¿ï¼‰åœ¨ç»•Yè½´æ—‹è½¬æ—¶å½¢æˆçš„ä¸‰ç»´æ—‹è½¬ä½“ã€‚æ‘†çº¿å‚æ•°æ–¹ç¨‹ï¼šx = a(Î¸ - sinÎ¸), y = a(1 - cosÎ¸)</p>
    </div>
    
    <div class="container">
        <div id="canvas-container"></div>
        
        <div class="controls-panel">
            <div class="control-group">
                <div class="control-title">ğŸ›ï¸ æ—‹è½¬æ§åˆ¶</div>
                <div class="slider-container">
                    <label>æ—‹è½¬é€Ÿåº¦: <span id="speed-value" class="value-display">0.5</span></label>
                    <input type="range" id="speed-control" min="0" max="1" step="0.01" value="0.5">
                </div>
                <div class="slider-container">
                    <label>æ—‹è½¬è§’åº¦: <span id="angle-value" class="value-display">0Â°</span></label>
                    <input type="range" id="angle-control" min="0" max="360" step="1" value="0">
                </div>
                <div class="button-group">
                    <button id="play-pause">æš‚åœ</button>
                    <button id="reset">é‡ç½®</button>
                    <button id="complete-rotation">å®Œæ•´æ—‹è½¬</button>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">âš™ï¸ æ‘†çº¿å‚æ•°</div>
                <div class="slider-container">
                    <label>æ»šåœ†åŠå¾„ (a): <span id="radius-value" class="value-display">2.0</span></label>
                    <input type="range" id="radius-control" min="0.5" max="5" step="0.1" value="2.0">
                </div>
                <div class="slider-container">
                    <label>Î¸èŒƒå›´: <span id="theta-value" class="value-display">2Ï€</span></label>
                    <input type="range" id="theta-control" min="1" max="6.28" step="0.01" value="6.28">
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">ğŸ¨ è§†è§‰æ•ˆæœ</div>
                <div class="slider-container">
                    <label>çº¿æ¡†é€æ˜åº¦: <span id="opacity-value" class="value-display">0.3</span></label>
                    <input type="range" id="opacity-control" min="0" max="1" step="0.05" value="0.3">
                </div>
                <div class="slider-container">
                    <label>è¡¨é¢ç»†èŠ‚: <span id="detail-value" class="value-display">50</span></label>
                    <input type="range" id="detail-control" min="10" max="100" step="5" value="50">
                </div>
                <div class="button-group">
                    <button id="wireframe-toggle">æ˜¾ç¤ºå®ä½“</button>
                    <button id="show-path">æ˜¾ç¤ºè½¨è¿¹</button>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4facfe;"></div>
                        <span>åŸå§‹æ‘†çº¿</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff4f7b;"></div>
                        <span>æ—‹è½¬ä½“è¡¨é¢</span>
                    </div>
                </div>
            </div>
            
            <div class="info-box">
                <h3>ğŸ“š æ•™å­¦è¯´æ˜</h3>
                <p>æ‘†çº¿æ˜¯åœ†å‘¨ä¸Šä¸€ç‚¹åœ¨ç›´çº¿æ»šåŠ¨æ—¶å½¢æˆçš„è½¨è¿¹ã€‚ç»•Yè½´æ—‹è½¬åï¼Œå½¢æˆå…·æœ‰ç‰¹æ®Šå‡ ä½•æ€§è´¨çš„ä¸‰ç»´æ—‹è½¬ä½“ã€‚</p>
                <p>æ—‹è½¬ä½“ä½“ç§¯å…¬å¼ï¼šV = Ï€âˆ«[x(y)]Â² dyï¼Œå…¶ä¸­x(y)æ˜¯æ‘†çº¿æ–¹ç¨‹ã€‚</p>
                <p>é€šè¿‡è°ƒæ•´å‚æ•°ï¼Œå¯ä»¥è§‚å¯Ÿä¸åŒåŠå¾„å’ŒÎ¸èŒƒå›´å¯¹æ—‹è½¬ä½“å½¢çŠ¶çš„å½±å“ã€‚</p>
                
                <div class="param-display">
                    <div class="param-item">
                        <div class="param-label">å½“å‰ä½“ç§¯è¿‘ä¼¼å€¼ï¼š</div>
                        <div class="param-value" id="volume-value">0.00</div>
                    </div>
                    <div class="param-item">
                        <div class="param-label">è¡¨é¢ç§¯è¿‘ä¼¼å€¼ï¼š</div>
                        <div class="param-value" id="surface-value">0.00</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let curveObject = null;
        let surfaceObject = null;
        let pathObjects = [];
        let animationId = null;
        let isPlaying = true;
        let rotationAngle = 0;
        let rotationSpeed = 0.5;
        let showWireframe = true;
        let showPath = false;
        let radius = 2.0;
        let thetaMax = 2 * Math.PI;
        let detail = 50;
        
        // åˆå§‹åŒ–
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c0c2e);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 5, 10);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            const canvasContainer = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            canvasContainer.appendChild(renderer.domElement);
            
            // æ·»åŠ è½¨é“æ§åˆ¶
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 15);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // æ·»åŠ åæ ‡è½´
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // åˆ›å»ºç½‘æ ¼åœ°é¢
            const gridHelper = new THREE.GridHelper(20, 20, 0x444477, 0x222244);
            gridHelper.position.y = -radius * 2;
            scene.add(gridHelper);
            
            // åˆå§‹åŒ–æ‘†çº¿å’Œæ—‹è½¬ä½“
            createCycloidCurve();
            createRotationSurface();
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }
        
        // åˆ›å»ºæ‘†çº¿æ›²çº¿
        function createCycloidCurve() {
            if (curveObject) scene.remove(curveObject);
            
            const points = [];
            const step = thetaMax / detail;
            
            // ç”Ÿæˆæ‘†çº¿ç‚¹
            for (let i = 0; i <= detail; i++) {
                const theta = i * step;
                const x = radius * (theta - Math.sin(theta));
                const y = radius * (1 - Math.cos(theta));
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            // åˆ›å»ºæ›²çº¿
            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(curve, 200, 0.05, 8, false);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4facfe,
                emissive: 0x1a4f7e,
                shininess: 100
            });
            
            curveObject = new THREE.Mesh(geometry, material);
            scene.add(curveObject);
        }
        
        // åˆ›å»ºæ—‹è½¬ä½“è¡¨é¢
        function createRotationSurface() {
            if (surfaceObject) scene.remove(surfaceObject);
            
            const vertices = [];
            const indices = [];
            
            const thetaStep = thetaMax / detail;
            const phiStep = (2 * Math.PI) / detail;
            
            // ç”Ÿæˆè¡¨é¢é¡¶ç‚¹
            for (let i = 0; i <= detail; i++) {
                const theta = i * thetaStep;
                const x = radius * (theta - Math.sin(theta));
                const y = radius * (1 - Math.cos(theta));
                
                for (let j = 0; j <= detail; j++) {
                    const phi = j * phiStep;
                    
                    // ç»•Yè½´æ—‹è½¬
                    const rotatedX = x * Math.cos(phi);
                    const rotatedZ = x * Math.sin(phi);
                    
                    vertices.push(rotatedX, y, rotatedZ);
                }
            }
            
            // ç”Ÿæˆè¡¨é¢ç´¢å¼•
            for (let i = 0; i < detail; i++) {
                for (let j = 0; j < detail; j++) {
                    const a = i * (detail + 1) + j;
                    const b = a + 1;
                    const c = (i + 1) * (detail + 1) + j;
                    const d = c + 1;
                    
                    indices.push(a, b, d);
                    indices.push(a, d, c);
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                color: 0xff4f7b,
                transparent: true,
                opacity: 0.3,
                wireframe: true,
                emissive: 0x4f1a2a,
                side: THREE.DoubleSide
            });
            
            surfaceObject = new THREE.Mesh(geometry, material);
            scene.add(surfaceObject);
            
            // æ›´æ–°ä½“ç§¯å’Œè¡¨é¢ç§¯æ˜¾ç¤º
            updateVolumeAndSurface();
        }
        
        // æ›´æ–°ä½“ç§¯å’Œè¡¨é¢ç§¯æ˜¾ç¤º
        function updateVolumeAndSurface() {
            // ä½¿ç”¨æ—‹è½¬ä½“ä½“ç§¯å…¬å¼è¿‘ä¼¼è®¡ç®—
            // V = Ï€ âˆ«[x(y)]Â² dy
            let volume = 0;
            let surfaceArea = 0;
            const step = thetaMax / 100;
            
            for (let i = 0; i < 100; i++) {
                const theta = i * step;
                const nextTheta = (i + 1) * step;
                
                const x = radius * (theta - Math.sin(theta));
                const nextX = radius * (nextTheta - Math.sin(nextTheta));
                
                const y = radius * (1 - Math.cos(theta));
                const nextY = radius * (1 - Math.cos(nextTheta));
                
                // ä½“ç§¯è¿‘ä¼¼ (åœ†ç›˜æ³•)
                const avgX = (x + nextX) / 2;
                const dy = nextY - y;
                volume += Math.PI * avgX * avgX * dy;
                
                // è¡¨é¢ç§¯è¿‘ä¼¼ (æ—‹è½¬æ›²é¢é¢ç§¯)
                const dx = nextX - x;
                const ds = Math.sqrt(dx * dx + dy * dy);
                const avgRadius = (x + nextX) / 2;
                surfaceArea += 2 * Math.PI * avgRadius * ds;
            }
            
            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('volume-value').textContent = Math.abs(volume).toFixed(2);
            document.getElementById('surface-value').textContent = Math.abs(surfaceArea).toFixed(2);
        }
        
        // æ·»åŠ æ—‹è½¬è½¨è¿¹
        function addPathPoint() {
            if (!showPath) return;
            
            // æ¸…é™¤æ—§è·¯å¾„ç‚¹
            if (pathObjects.length > 30) {
                scene.remove(pathObjects[0]);
                pathObjects.shift();
            }
            
            // åˆ›å»ºå½“å‰è§’åº¦çš„æ‘†çº¿
            const points = [];
            const step = thetaMax / 20;
            
            for (let i = 0; i <= 20; i++) {
                const theta = i * step;
                const x = radius * (theta - Math.sin(theta));
                const y = radius * (1 - Math.cos(theta));
                
                // ç»•Yè½´æ—‹è½¬å½“å‰è§’åº¦
                const rotatedX = x * Math.cos(rotationAngle);
                const rotatedZ = x * Math.sin(rotationAngle);
                
                points.push(new THREE.Vector3(rotatedX, y, rotatedZ));
            }
            
            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(curve, 50, 0.02, 8, false);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.6
            });
            
            const path = new THREE.Mesh(geometry, material);
            scene.add(path);
            pathObjects.push(path);
        }
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // æ—‹è½¬é€Ÿåº¦æ§åˆ¶
            document.getElementById('speed-control').addEventListener('input', function(e) {
                rotationSpeed = parseFloat(e.target.value);
                document.getElementById('speed-value').textContent = rotationSpeed.toFixed(2);
            });
            
            // æ—‹è½¬è§’åº¦æ§åˆ¶
            document.getElementById('angle-control').addEventListener('input', function(e) {
                rotationAngle = parseFloat(e.target.value) * Math.PI / 180;
                document.getElementById('angle-value').textContent = e.target.value + 'Â°';
                updateSurfaceRotation();
            });
            
            // åŠå¾„æ§åˆ¶
            document.getElementById('radius-control').addEventListener('input', function(e) {
                radius = parseFloat(e.target.value);
                document.getElementById('radius-value').textContent = radius.toFixed(1);
                createCycloidCurve();
                createRotationSurface();
            });
            
            // Î¸èŒƒå›´æ§åˆ¶
            document.getElementById('theta-control').addEventListener('input', function(e) {
                thetaMax = parseFloat(e.target.value);
                document.getElementById('theta-value').textContent = thetaMax.toFixed(2);
                createCycloidCurve();
                createRotationSurface();
            });
            
            // é€æ˜åº¦æ§åˆ¶
            document.getElementById('opacity-control').addEventListener('input', function(e) {
                const opacity = parseFloat(e.target.value);
                document.getElementById('opacity-value').textContent = opacity.toFixed(2);
                if (surfaceObject) {
                    surfaceObject.material.opacity = opacity;
                }
            });
            
            // ç»†èŠ‚æ§åˆ¶
            document.getElementById('detail-control').addEventListener('input', function(e) {
                detail = parseInt(e.target.value);
                document.getElementById('detail-value').textContent = detail;
                createCycloidCurve();
                createRotationSurface();
            });
            
            // æ’­æ”¾/æš‚åœæŒ‰é’®
            document.getElementById('play-pause').addEventListener('click', function() {
                isPlaying = !isPlaying;
                this.textContent = isPlaying ? 'æš‚åœ' : 'æ’­æ”¾';
            });
            
            // é‡ç½®æŒ‰é’®
            document.getElementById('reset').addEventListener('click', function() {
                rotationAngle = 0;
                document.getElementById('angle-control').value = 0;
                document.getElementById('angle-value').textContent = '0Â°';
                updateSurfaceRotation();
                
                // æ¸…é™¤è·¯å¾„
                pathObjects.forEach(obj => scene.remove(obj));
                pathObjects = [];
            });
            
            // å®Œæ•´æ—‹è½¬æŒ‰é’®
            document.getElementById('complete-rotation').addEventListener('click', function() {
                rotationAngle = 2 * Math.PI;
                document.getElementById('angle-control').value = 360;
                document.getElementById('angle-value').textContent = '360Â°';
                updateSurfaceRotation();
            });
            
            // çº¿æ¡†åˆ‡æ¢æŒ‰é’®
            document.getElementById('wireframe-toggle').addEventListener('click', function() {
                showWireframe = !showWireframe;
                if (surfaceObject) {
                    surfaceObject.material.wireframe = showWireframe;
                    this.textContent = showWireframe ? 'æ˜¾ç¤ºå®ä½“' : 'æ˜¾ç¤ºçº¿æ¡†';
                }
            });
            
            // æ˜¾ç¤ºè½¨è¿¹æŒ‰é’®
            document.getElementById('show-path').addEventListener('click', function() {
                showPath = !showPath;
                this.textContent = showPath ? 'éšè—è½¨è¿¹' : 'æ˜¾ç¤ºè½¨è¿¹';
                
                if (!showPath) {
                    pathObjects.forEach(obj => scene.remove(obj));
                    pathObjects = [];
                }
            });
        }
        
        // æ›´æ–°è¡¨é¢æ—‹è½¬
        function updateSurfaceRotation() {
            if (!surfaceObject) return;
            
            const vertices = surfaceObject.geometry.attributes.position.array;
            const thetaStep = thetaMax / detail;
            const phiStep = (2 * Math.PI) / detail;
            
            let vertexIndex = 0;
            for (let i = 0; i <= detail; i++) {
                const theta = i * thetaStep;
                const x = radius * (theta - Math.sin(theta));
                const y = radius * (1 - Math.cos(theta));
                
                for (let j = 0; j <= detail; j++) {
                    const phi = j * phiStep + rotationAngle;
                    
                    // ç»•Yè½´æ—‹è½¬
                    const rotatedX = x * Math.cos(phi);
                    const rotatedZ = x * Math.sin(phi);
                    
                    vertices[vertexIndex] = rotatedX;
                    vertices[vertexIndex + 1] = y;
                    vertices[vertexIndex + 2] = rotatedZ;
                    
                    vertexIndex += 3;
                }
            }
            
            surfaceObject.geometry.attributes.position.needsUpdate = true;
            surfaceObject.geometry.computeVertexNormals();
            
            // æ·»åŠ è·¯å¾„ç‚¹
            addPathPoint();
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            if (isPlaying) {
                // æ›´æ–°æ—‹è½¬è§’åº¦
                rotationAngle += 0.01 * rotationSpeed;
                if (rotationAngle > 2 * Math.PI) rotationAngle -= 2 * Math.PI;
                
                // æ›´æ–°UI
                const angleDeg = (rotationAngle * 180 / Math.PI).toFixed(0);
                document.getElementById('angle-control').value = angleDeg;
                document.getElementById('angle-value').textContent = angleDeg + 'Â°';
                
                // æ›´æ–°è¡¨é¢
                updateSurfaceRotation();
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            const canvasContainer = document.getElementById('canvas-container');
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>